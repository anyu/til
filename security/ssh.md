# SSH

## Overview
- SSH (Secure Shell) is a protocol that uses encryption to secure the connection between a client (SSH client) and a server (SSH server). All user authentication, commands, output, and file transfers are encrypted.
- Most common application = remote command-line login, remote command execution. But any network service can be secured with SSH.
- By default, the SSH server runs on TCP port 22. This can be changed in /etc/ssh/sshd_config (may need to restart sshd after) It can also be specified using the -p <port> option to sshd. The CLI setting overrides config settings.

## How it works
Requirements: SSH daemon program needs to be running on server. SSH client program needs to be running on client (Terminal is a built-in SSH client on Macs)
1. --> Client initiates connection by contact server.
1. <-- Serve sends server public key.
1. <--> Both negotiate parameters and open secure channel.
1. --> User logs into server host OS.

## How SSH authenticates users
- SSH keys can be used to automate access to servers. They act similar to passwords; they grant access and control who can access what.
- Key pairs can be generated by the ssh-keygen utility. By default, the generated public key will be in ~/.ssh/id_rsa.pub and the private key will be in ~/.ssh/id_rsa (older versions = ~/.ssh/identity, ~/.ssh/identity.pub)
- Each SSH key pair includes two keys:
  - the public key is copied to the SSH server(s), via ssh-copy-id. Can be shared. Anyone with the public key can encrypt data which can only be read by the user with the matching private key. Once an SSH server receives a public key from a user and considers the key trustworthy, the server marks the key as authorized in its authorized_keys file (~/.ssh/authorized_keys; location can be changed). These keys are called authorized keys.
  - the private key (aka. identity key) remains with the user. Don't share. Similar to host keys, but identity keys are used for authenticating users, whereas host keys are used for authenticating computers.
- When the public key is on the remote end and the matching private key is on the local end, no password is needed. Though the private key itself can be locked with a password.

## SSH agent
- `ssh-agent` is a background program that keeps track of user's private keys so you don't need to enter your passphrase every time you need to use the key.
- On most Linux systems, ssh-agent is automatically configured and run at login. If not, it can be started manually with eval 'ssh-agent', which sets some env vars. To check if the agent is running, check if SSH_AGENT_SOCK environment variable is set (note need to run eval $(ssh-agent) if want env vars accessible in the same shell)
- By default, the agent uses SSH keys stored in the .ssh directory under the user's home directory.
- `ssh-add` adds identities to the agent. Run w/o args to add the default file ~/.ssh/id_rsa (other/older variations that will also be added: .ssh/id_dsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ed25519, ~/.ssh/identity). Otherwise, give it the name of the private key file to add.

- `ssh-add -l`   // check if agent has identities
- `ssh-add -D`    // delete agent identities 
- `kill $SSH_AGENT_PID`   // kill agent (can autorun on logout by placing in `.bash_logout`)

## SSH agent forwarding
- An SSH client can let SSH servers use the local ssh-agent as if they were already running on the server (eg. if you need to double SSH)
- Open or create if doesn't exist: ~/.ssh/config. Add:
- Host example.com
ForwardAgent yes

## SSH daemon
- The server machine must be running an SSH daemon (`sshd). This program listens for connections from clients (on a specific network port), authenticates connection requests, and spawns the appropriate environment if the user provides the correct credentials.
- It's normally started at boot from /etc/rc. It forks a new daemon for each incoming connection.

## More Info

### Configuring SSH access through firewalls
- Frequently permitted through firewalls: Unrestricted outbound SSH is very common; inbound SSH is usually restricted to very few servers.
- Configuring outbound SSH in a firewall is very easy. Just create a rule that allows TCP port 22 to go out. But there's the risk of back-tunneling.

### SSH tunneling
- SSH supports tunneling. It's possible to have an SSH server on an external server listens to connections from anywhere, forward those back into the organization, and then make a connection to some internal server. This is convenient because you can open a tunnel to gain remote access to work machines from home. But this can be used by hackers to leave backdoors into organizations.

### Inbound SSH access

#### Alternatives:
- Use different ports on the firewall to access different servers.
- Only allow SSH access after you have logged in using a VPN.

### Enabling access via iptables
- Iptables = host firewall built into Linux kernel.
- Usually configured to protect the server by preventing access to ports that haven't been specifically opened.
- If iptables is enabled on the server, these commands can be used to allow incoming SSH access (must be run as root):
- `iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT`
- `iptables -A OUTPUT -p tcp --sport 22 -m conntrack --ctstate ESTABLISHED -j ACCEPT`

## Reverse-SSH tunnel

- Created by Tatu Ylonen, a researcher at Helsinki University of Technology in Finland.
- Designed as a replacement for telnet (port 23, non-protected login) and FTP (port 21, insecure file transfer).
openssh
- WikiLeaks found that the CIA can intercept SSH connections started by SSH clients on compromised machines.